# GBNF Grammar for a subset of the jq language
# Author: Nikolay Sedelnikov
# Based on analysis of real-world jq queries and jq documentation

# This grammar covers core jq features including:
# - Basic expressions, pipelines, and operators
# - Path expressions, variables, and function calls
# - Array/object construction and conditionals
# - Common built-in functions
#
# Excluded for simplicity:
# - try-catch, reduce, foreach, def (function definitions)
# - Some advanced features and less common operators
# - A good set of built in functions is included, but not all
#
# This grammar is a stripped down version of the full jq language grammar,
# focusing on the most commonly used constructs for practical filtering and selection tasks.
# Complex features are omitted to keep the grammar manageable and to reduce potential LLM generation errors.
#


root ::= expression

# The core of jq is a pipeline of expressions
expression ::= ws term (ws "|" ws term)* ws

# A term can be a simple value/path or a more complex operation
term ::=
    (if-expression |
    assignment-expression |
    logic-or) (ws "as" ws variable)?

# Operator precedence hierarchy
logic-or ::= logic-and (ws "or" ws logic-and)*
logic-and ::= comparison (ws "and" ws comparison)*
comparison ::= alternative (ws ("==" | "!=" | ">=" | "<=" | ">" | "<") ws alternative)*
alternative ::= addition (ws "//" ws addition)*
addition ::= multiplication (ws ("+" | "-") ws multiplication)*
multiplication ::= unary (ws ("*" | "/" | "%") ws unary)*
unary ::= ("-" | "+")? primary

# Primary expressions
primary ::=
    literal |
    path-expression |
    variable |
    function-call |
    "(" ws expression ws ")" |
    array-constructor |
    object-constructor

# Literals: string, number, boolean, null
literal ::= number | string | boolean | "null"
boolean ::= "true" | "false"
number ::= ("-")? ([0-9]+ | [0-9]+ "." [0-9]+ | "." [0-9]+) ([eE] [-+]? [0-9]+)?
string ::=
    "\"" (
        [^"\\\n] |
        "\\" (["\"\\/bfnrt] | "u" [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]) |
        "\\(" expression ")" # String interpolation. Might be scoped down further for simplicity.
    )* "\""

# Identifiers and Variables
identifier ::= [a-zA-Z_] [a-zA-Z0-9_]*
variable ::= "$" identifier

# Path Expressions: .foo, .[0], .["foo-bar"], .[], ..
path-expression ::= ("." | "..")? path-component+ | "." | ".."
path-component ::=
    (ws "." ws (identifier | string)) |
    (ws "[" ws (string | number | slice | "") ws "]") |
    "?"

slice ::= number? ":" number?

# Function Calls: map(...), select, length
function-call ::= built-in-fn ("(" ws (expression (ws ";" ws expression)*)? ws ")")?
built-in-fn ::=
    "add" | "all" | "any" | "ascii_downcase" | "ascii_upcase" |
    "capture" | "contains" | "endswith" |
    "first" | "flatten" | "floor" | "fromjson" |
    "group_by" | "gsub" | "has" | "index" | "isempty" |
    "join" | "keys" | "keys_unsorted" | "last" | "length" | "ltrimstr" |
    "map" | "map_values" | "match" | "max" | "max_by" | "min" | "min_by" |
    "not" | "nth" | "objects" | "pow" |
    "recurse" | "reverse" | "round" | "rtrimstr" | "scalars" | "select" |
    "sort" | "sort_by" | "split" | "startswith" | "sub" |
    "test" | "tojson" | "tonumber" | "tostring" |
    "type" | "unique" | "unique_by" | "values" | "walk"

# Array and Object Construction
array-constructor ::= "[" ws (expression (ws "," ws expression)*)? ws "]"
object-constructor ::= "{" ws (pair (ws "," ws pair)*)? ws "}"
pair ::= (string | identifier) ws ":" ws expression | identifier | variable

# Assignments
assignment-expression ::= path-expression ws ("=" | "|=" | "+=" | "-=" | "*=" | "/=") ws expression

# Control Flow and Definitions
# 'try-catch', 'reduce', 'foreach' and 'def' are excluded to simplify the grammar
if-expression ::= "if" ws expression ws "then" ws expression (ws "elif" ws expression ws "then" ws expression)* ws "else" ws expression ws "end"

# Whitespace
ws ::= ([ \t\n\r]+)?
